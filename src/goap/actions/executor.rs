//! Plan executor implementation
//!
//! The PlanExecutor is responsible for executing action plans generated by the GOAP planner.

use crate::goap::actions::ActionType;
use serde::{Deserialize, Serialize};

/// Execution status for a single action
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum ExecutionStatus {
    /// Action executed successfully
    Success,

    /// Action failed but was recovered
    RecoveredError,

    /// Action failed completely
    Failed,
}

/// Represents a single step in plan execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionStep {
    /// The action that was executed
    pub action: ActionType,

    /// Execution status
    pub status: ExecutionStatus,

    /// Actual execution time in milliseconds
    pub duration_ms: u64,

    /// Tokens consumed by this action
    pub tokens_used: u32,

    /// Error message if action failed
    pub error: Option<String>,
}

impl ExecutionStep {
    /// Create a new execution step
    pub fn new(
        action: ActionType,
        status: ExecutionStatus,
        duration_ms: u64,
        tokens_used: u32,
    ) -> Self {
        ExecutionStep {
            action,
            status,
            duration_ms,
            tokens_used,
            error: None,
        }
    }

    /// Create a failed execution step
    pub fn failed(action: ActionType, duration_ms: u64, tokens_used: u32, error: String) -> Self {
        ExecutionStep {
            action,
            status: ExecutionStatus::Failed,
            duration_ms,
            tokens_used,
            error: Some(error),
        }
    }
}

/// Result of executing a complete plan
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionResult {
    /// Individual execution steps
    pub steps: Vec<ExecutionStep>,

    /// Total tokens consumed
    pub total_tokens_used: u32,

    /// Total execution time
    pub total_duration_ms: u64,

    /// Whether the plan succeeded
    pub success: bool,

    /// Final response if successful
    pub response: Option<String>,

    /// Number of replans performed
    pub replan_count: u32,
}

impl ExecutionResult {
    /// Create a new empty execution result
    pub fn new() -> Self {
        ExecutionResult {
            steps: Vec::new(),
            total_tokens_used: 0,
            total_duration_ms: 0,
            success: false,
            response: None,
            replan_count: 0,
        }
    }

    /// Add a step to the result
    pub fn add_step(&mut self, step: ExecutionStep) {
        self.steps.push(step.clone());
        self.total_tokens_used += step.tokens_used;
        self.total_duration_ms += step.duration_ms;
    }

    /// Mark execution as successful
    pub fn mark_success(&mut self, response: String) {
        self.success = true;
        self.response = Some(response);
    }

    /// Mark execution as failed
    pub fn mark_failed(&mut self) {
        self.success = false;
    }

    /// Increment replan count
    pub fn increment_replans(&mut self) {
        self.replan_count += 1;
    }

    /// Get success rate (percentage of successful steps)
    pub fn success_rate(&self) -> f64 {
        if self.steps.is_empty() {
            return 0.0;
        }
        let successful_steps = self
            .steps
            .iter()
            .filter(|s| {
                s.status == ExecutionStatus::Success || s.status == ExecutionStatus::RecoveredError
            })
            .count();
        successful_steps as f64 / self.steps.len() as f64
    }
}

impl Default for ExecutionResult {
    fn default() -> Self {
        Self::new()
    }
}

/// Executor for GOAP action plans
#[derive(Debug, Clone)]
pub struct PlanExecutor {
    /// Maximum execution time in milliseconds
    max_execution_time_ms: u64,

    /// Maximum number of retries per action
    max_retries: u32,
}

impl PlanExecutor {
    /// Create a new plan executor
    pub fn new() -> Self {
        PlanExecutor {
            max_execution_time_ms: 30000, // 30 seconds default
            max_retries: 3,
        }
    }

    /// Create a new plan executor with custom configuration
    pub fn with_max_time(max_time_ms: u64) -> Self {
        PlanExecutor {
            max_execution_time_ms: max_time_ms,
            max_retries: 3,
        }
    }

    /// Set maximum execution time
    pub fn max_execution_time(mut self, max_time_ms: u64) -> Self {
        self.max_execution_time_ms = max_time_ms;
        self
    }

    /// Set maximum retries
    pub fn max_retries(mut self, max_retries: u32) -> Self {
        self.max_retries = max_retries;
        self
    }

    /// Execute a plan (TODO: Implement actual execution logic)
    pub async fn execute_plan(
        &self,
        _plan: Vec<ActionType>,
        _initial_state: &mut crate::goap::world::WorldState,
    ) -> Result<ExecutionResult, String> {
        // TODO: Implement actual plan execution
        Ok(ExecutionResult::new())
    }
}

impl Default for PlanExecutor {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_execution_step_creation() {
        let step = ExecutionStep::new(
            ActionType::GenerateResponse,
            ExecutionStatus::Success,
            100,
            50,
        );
        assert_eq!(step.action, ActionType::GenerateResponse);
        assert_eq!(step.status, ExecutionStatus::Success);
        assert_eq!(step.duration_ms, 100);
        assert_eq!(step.tokens_used, 50);
    }

    #[test]
    fn test_execution_result() {
        let mut result = ExecutionResult::new();
        let step = ExecutionStep::new(
            ActionType::GenerateResponse,
            ExecutionStatus::Success,
            100,
            50,
        );
        result.add_step(step);
        assert_eq!(result.steps.len(), 1);
        assert_eq!(result.total_tokens_used, 50);
        assert_eq!(result.total_duration_ms, 100);
        assert_eq!(result.success_rate(), 1.0);
    }

    #[test]
    fn test_execution_result_success() {
        let mut result = ExecutionResult::new();
        result.mark_success("Test response".to_string());
        assert!(result.success);
        assert_eq!(result.response, Some("Test response".to_string()));
    }
}
